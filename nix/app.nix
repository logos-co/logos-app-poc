# Builds the logos-app standalone application
{ pkgs, common, src, logosLiblogos, logosSdk, logosDesignSystem, logosPackageManager, preinstallPkgs ? [], portable ? false }:

let
  # webkitgtk became ABI-versioned; pick the newest available while staying
  # compatible with older nixpkgs where the unversioned attribute still exists.
  webkitgtk = pkgs.webkitgtk_4_1 or pkgs.webkitgtk_4_0 or pkgs.webkitgtk;
in
pkgs.stdenv.mkDerivation rec {
  pname = "logos-app";
  version = common.version;

  inherit src;
  # Platform-specific build inputs for system webviews
  buildInputs = common.buildInputs ++ [
    pkgs.qt6.qtwebview
    pkgs.qt6.qtdeclarative
  ] ++ (
    if pkgs.stdenv.isLinux then
      # Linux: WebKitGTK as backend
      [ webkitgtk ]
    else
      []
  );
  inherit (common) meta;

  # Add logosSdk to nativeBuildInputs for logos-cpp-generator
  nativeBuildInputs = common.nativeBuildInputs ++ [ logosSdk pkgs.patchelf pkgs.removeReferencesTo ];

  # Provide Qt/GL runtime paths so the wrapper can inject them
  qtLibPath = pkgs.lib.makeLibraryPath (
    [
      pkgs.qt6.qtbase
      pkgs.qt6.qtremoteobjects
      pkgs.qt6.qtwebview
      pkgs.qt6.qtdeclarative
      pkgs.zstd
      pkgs.krb5
      pkgs.zlib
      pkgs.glib
      pkgs.stdenv.cc.cc
      pkgs.freetype
      pkgs.fontconfig
    ]
    ++ pkgs.lib.optionals pkgs.stdenv.isLinux [
      pkgs.libglvnd
      pkgs.mesa.drivers
      pkgs.xorg.libX11
      pkgs.xorg.libXext
      pkgs.xorg.libXrender
      pkgs.xorg.libXrandr
      pkgs.xorg.libXcursor
      pkgs.xorg.libXi
      pkgs.xorg.libXfixes
      pkgs.xorg.libxcb
    ]
  );
  qtPluginPath = "${pkgs.qt6.qtbase}/lib/qt-6/plugins:${pkgs.qt6.qtwebview}/lib/qt-6/plugins";
  qmlImportPath = "${placeholder "out"}/lib:${pkgs.qt6.qtdeclarative}/lib/qt-6/qml:${pkgs.qt6.qtwebview}/lib/qt-6/qml";

  preConfigure = ''
    runHook prePreConfigure

    # Set macOS deployment target to match Qt frameworks
    export MACOSX_DEPLOYMENT_TARGET=12.0

    # Copy logos-cpp-sdk headers to expected location
    echo "Copying logos-cpp-sdk headers for app..."
    mkdir -p ./logos-cpp-sdk/include/cpp
    cp -r ${logosSdk}/include/cpp/* ./logos-cpp-sdk/include/cpp/

    # Also copy core headers
    echo "Copying core headers..."
    mkdir -p ./logos-cpp-sdk/include/core
    cp -r ${logosSdk}/include/core/* ./logos-cpp-sdk/include/core/

    # Copy SDK library files to lib directory
    echo "Copying SDK library files..."
    mkdir -p ./logos-cpp-sdk/lib
    if [ -f "${logosSdk}/lib/liblogos_sdk.dylib" ]; then
      cp "${logosSdk}/lib/liblogos_sdk.dylib" ./logos-cpp-sdk/lib/
    elif [ -f "${logosSdk}/lib/liblogos_sdk.so" ]; then
      cp "${logosSdk}/lib/liblogos_sdk.so" ./logos-cpp-sdk/lib/
    elif [ -f "${logosSdk}/lib/liblogos_sdk.a" ]; then
      cp "${logosSdk}/lib/liblogos_sdk.a" ./logos-cpp-sdk/lib/
    fi

    runHook postPreConfigure
  '';

  # preinstall/ is carried into portable bundles by nix-bundle-dir
  passthru = { extraDirs = [ "preinstall" ]; };

  # This is an aggregate runtime layout; avoid stripping to prevent hook errors
  dontStrip = true;

  # Skip wrapQtApps: wrapper renames binary to .LogosApp-wrapped; macOS Dock uses executable filename
  # We create a custom launcher that execs the binary (keeps process name "LogosApp")
  dontWrapQtApps = true;

  # Additional environment variables for Qt and RPATH cleanup
  preFixup = ''
    runHook prePreFixup

    # Set up Qt environment variables
    export QT_PLUGIN_PATH="${pkgs.qt6.qtbase}/lib/qt-6/plugins:${pkgs.qt6.qtwebview}/lib/qt-6/plugins"
    export QML2_IMPORT_PATH="${pkgs.qt6.qtdeclarative}/lib/qt-6/qml:${pkgs.qt6.qtwebview}/lib/qt-6/qml"

    # Remove any remaining references to /build/ in binaries and set proper RPATH
    find $out -type f -executable -exec sh -c '
      if file "$1" | grep -q "ELF.*executable"; then
        # Use patchelf to clean up RPATH if it contains /build/
        if patchelf --print-rpath "$1" 2>/dev/null | grep -q "/build/"; then
          echo "Cleaning RPATH for $1"
          patchelf --remove-rpath "$1" 2>/dev/null || true
        fi
        # Set proper RPATH for the main binary
        if echo "$1" | grep -q "/LogosApp$"; then
          echo "Setting RPATH for $1"
          patchelf --set-rpath "$out/lib" "$1" 2>/dev/null || true
        fi
      fi
    ' _ {} \;

    # Also clean up shared libraries
    find $out -name "*.so" -exec sh -c '
      if patchelf --print-rpath "$1" 2>/dev/null | grep -q "/build/"; then
        echo "Cleaning RPATH for $1"
        patchelf --remove-rpath "$1" 2>/dev/null || true
      fi
    ' _ {} \;

    runHook prePostFixup
  '';

  configurePhase = ''
    runHook preConfigure

    echo "Configuring logos-app..."
    echo "liblogos: ${logosLiblogos}"
    echo "cpp-sdk: ${logosSdk}"
    echo "logos-design-system: ${logosDesignSystem}"

    # Verify that the built components exist
    test -d "${logosLiblogos}" || (echo "liblogos not found" && exit 1)
    test -d "${logosSdk}" || (echo "cpp-sdk not found" && exit 1)
    test -d "${logosDesignSystem}" || (echo "logos-design-system not found" && exit 1)

    cmake -S app -B build \
      -GNinja \
      -DCMAKE_BUILD_TYPE=Release \
      -DCMAKE_OSX_DEPLOYMENT_TARGET=12.0 \
      -DCMAKE_INSTALL_RPATH_USE_LINK_PATH=FALSE \
      -DCMAKE_INSTALL_RPATH="" \
      -DCMAKE_SKIP_BUILD_RPATH=TRUE \
      -DLOGOS_LIBLOGOS_ROOT=${logosLiblogos} \
      -DLOGOS_CPP_SDK_ROOT=$(pwd)/logos-cpp-sdk \
      -DLOGOS_PORTABLE_BUILD=${if portable then "ON" else "OFF"}

    runHook postConfigure
  '';

  buildPhase = ''
    runHook preBuild

    cmake --build build
    echo "logos-app built successfully!"

    runHook postBuild
  '';

  installPhase = ''
    runHook preInstall

    # Create output directories
    mkdir -p $out/bin $out/lib $out/preinstall

    # Install our app binary (real binary, so Qt hook can wrap it)
    if [ -f "build/LogosApp" ]; then
      cp build/LogosApp "$out/bin/LogosApp"
      echo "Installed LogosApp binary"
    fi

    # Copy the core binaries from liblogos
    if [ -f "${logosLiblogos}/bin/logoscore" ]; then
      cp -L "${logosLiblogos}/bin/logoscore" "$out/bin/"
      echo "Installed logoscore binary"
    fi
    if [ -f "${logosLiblogos}/bin/logos_host" ]; then
      cp -L "${logosLiblogos}/bin/logos_host" "$out/bin/"
      echo "Installed logos_host binary"
    fi

    # Copy required shared libraries from liblogos
    if ls "${logosLiblogos}/lib/"liblogos_core.* >/dev/null 2>&1; then
      cp -L "${logosLiblogos}/lib/"liblogos_core.* "$out/lib/" || true
    fi

    # Copy SDK library if it exists
    if ls "${logosSdk}/lib/"liblogos_sdk.* >/dev/null 2>&1; then
      cp -L "${logosSdk}/lib/"liblogos_sdk.* "$out/lib/" || true
    fi

    # Bundle the package_manager_plugin library for direct use during preinstall.
    # On first boot, logos core can't load the package_manager module (it hasn't been
    # installed yet), so the app loads this bundled copy directly via QPluginLoader.
    if [ -d "${logosPackageManager}/lib" ]; then
      for f in "${logosPackageManager}/lib/"*; do
        if [ -f "$f" ]; then
          cp -L "$f" "$out/lib/" || true
        fi
      done
      echo "Bundled package_manager_plugin library"
    fi

    # Copy preinstall lgx packages â€” installed into the user's data directory on first launch.
    # Includes core modules (package_manager, capability_module) and all UI plugins.
    for pkg in ${pkgs.lib.concatStringsSep " " (map toString preinstallPkgs)}; do
      cp "$pkg"/*.lgx "$out/preinstall/"
    done
    echo "Populated preinstall/ with lgx packages"

    # Copy design system QML modules (Logos.Theme, Logos.Controls) for runtime
    if [ -d "${logosDesignSystem}/lib/Logos/Theme" ]; then
      mkdir -p "$out/lib/Logos"
      cp -R "${logosDesignSystem}/lib/Logos/Theme" "$out/lib/Logos/"
      echo "Copied Logos.Theme to lib/Logos/Theme/"
    fi
    if [ -d "${logosDesignSystem}/lib/Logos/Controls" ]; then
      mkdir -p "$out/lib/Logos"
      cp -R "${logosDesignSystem}/lib/Logos/Controls" "$out/lib/Logos/"
      echo "Copied Logos.Controls to lib/Logos/Controls/"
    fi

    # Note: webview_app QML and HTML files are now embedded in the plugin via qrc

    # Create launcher script (sets Qt env, execs binary - process name stays "LogosApp" for Dock)
    cat > $out/bin/logos-app << 'EOF'
#!/bin/sh
EOF
    echo "export QT_PLUGIN_PATH=\"${qtPluginPath}\"" >> $out/bin/logos-app
    echo "export QML2_IMPORT_PATH=\"${qmlImportPath}\"" >> $out/bin/logos-app
    echo "export DYLD_LIBRARY_PATH=\"${qtLibPath}:\$DYLD_LIBRARY_PATH\"" >> $out/bin/logos-app
    echo "export LD_LIBRARY_PATH=\"${qtLibPath}:\$LD_LIBRARY_PATH\"" >> $out/bin/logos-app
    echo 'exec "$(dirname "$0")/LogosApp" "$@"' >> $out/bin/logos-app
    chmod +x $out/bin/logos-app

    # Create a README for reference
    cat > $out/README.txt <<EOF
Logos App - Build Information
==================================
liblogos: ${logosLiblogos}
cpp-sdk: ${logosSdk}
logos-design-system: ${logosDesignSystem}

Runtime Layout:
    - Binary: $out/bin/LogosApp
- Libraries: $out/lib
- Preinstall packages: $out/preinstall (installed to user data dir on first launch)

Usage:
  $out/bin/LogosApp
EOF

    runHook postInstall
  '';

}
